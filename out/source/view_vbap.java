/* autogenerated by Processing revision 1286 on 2023-02-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class view_vbap extends PApplet {


Vbap v;

int n = 21;


 public void setup() {
    /* size commented out by preprocessor */;

    v = new Vbap(n);

}

 public void draw() {
    background(0);
    v.get_source_position(mouseX, mouseY);
    v.show();
}


class Vbap {

    PVector[] s;
    int n;
    float radius = width/2 - 50;
    float[] pos_rad;
    PVector origin = new PVector(width/2, height/2);

    Vbap(int ls_num) {
        n = ls_num;
        s = new PVector[ls_num];
        pos_rad = new float[n];
        float angle_step = 2 * PI/ls_num;

        for (int i = 0; i < ls_num; i++) {
            float p = angle_step * i;
            float x = radius * cos(p);
            float y = radius * sin(p);
            s[i] = new PVector(x, y);
            s[i].add(origin);
            pos_rad[i] = p;

        }
    }

     public void show() {
        fill(255);
        ellipse(origin.x, origin.y, 7, 7);
        fill(255, 0, 0);
        for (PVector p : s) {
            ellipse(p.x, p.y, 15, 15);
        }
        push();
        stroke(255);
        line(0, height/2, width, height/2);
        line(width/2, 0, width/2, height);
        pop();

    }

     public boolean is_intersect(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) {

        float den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (den == 0) {
            return false;
        }

        float t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4))/den;
        float u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2))/den;

        if (t > 0 && t < 1 && u > 0) {
            float xi = x1 + t * (x2 - x1);
            float yi = y1 + t * (y2 - y1);
            PVector intersect_point = new PVector(xi, yi);
            push();
            stroke(255);
            line(origin.x, origin.y, xi, yi);
            ellipse(xi, yi, 10, 10);
            pop();
            return true;
        }
        return false;
    }

     public int[] get_active_arc(float xsource, float ysource) {

        for (int j = 0; j < n; j++) {

            int curr = j;
            int next = (j + 1)%n;

            PVector s1 = s[curr];
            PVector s2 = s[next];

            boolean inter = is_intersect(s1.x, s1.y, s2.x, s2.y, origin.x, origin.y, xsource, ysource);

            if (inter) {
                int[] ans = {curr, next};
                return ans;
            }
        }
        return null;
    }
    
     public void get_source_position(float xsource, float ysource) {

        PVector source = new PVector(xsource, ysource);

        fill(0, 255, 0);
        ellipse(xsource, ysource, 10, 10);

        float source_angle = atan2(source.y, source.x);
        int index = -1;
        for (int i = 0; i < n; i++) {
            if (pos_rad[i] == source_angle) {
                index = i;
            }
        }
        push();
        stroke(255);
        if (index != -1) {
            line(source.x, source.y, s[index].x, s[index].y);
        } else {
            int[] pair = get_active_arc(source.x, source.y);
            if (pair != null) {
                line(source.x, source.y, s[pair[0]].x, s[pair[0]].y);
                line(source.x, source.y, s[pair[1]].x, s[pair[1]].y);
            }
        }
        pop();
    }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "view_vbap" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
